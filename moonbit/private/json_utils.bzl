"""JSON utilities for Bazel-MoonBit integration - PRIVATE"""

load("@bazel_skylib//lib:json.bzl", "to_json", "from_json")
load(":platforms.bzl", "generate_target_specific_json", "get_target_from_label")

def generate_bazel_to_moon_json(ctx, srcs, deps, is_main=False, is_test=False, target=None):
    """Generate JSON configuration for MoonBit compiler from Bazel context.
    
    This creates a hermetic JSON configuration that MoonBit can consume,
    containing all necessary build information while maintaining Bazel's
    dependency tracking and hermeticity.
    
    Args:
        target: Optional target platform (wasm, js, c, native). If None, auto-detected.
    """
    # Auto-detect target if not specified
    target = target or get_target_from_label(ctx)
    
    config = {
        "bazel": {
            "label": str(ctx.label),
            "workspace_name": ctx.workspace_name,
            "package_name": ctx.label.package,
            "target_name": ctx.label.name,
            "is_main": is_main,
            "is_test": is_test,
            "platform": str(ctx.platform),
            "configuration": str(ctx.configuration),
        },
        "sources": [f.path for f in srcs],
        "dependencies": [],
        "options": {
            "target": target,  # Use specified or auto-detected target
            "optimization": "release",
            "debug_info": False,
            "output_format": "json",
        },
        "target_specific": generate_target_specific_json(ctx, target, None)
    }
    
    # Process dependencies to maintain hermeticity
    for dep in deps:
        if hasattr(dep, 'label'):
            dep_info = {
                "label": str(dep.label),
                "package": dep.label.package,
                "name": dep.label.name,
            }
            
            # Include metadata if available
            if hasattr(dep, 'metadata'):
                dep_info["metadata"] = dep.metadata
            
            # Add target compatibility info
            dep_info["target_compatibility"] = {
                "compatible_with": [target],  # Could be extended
                "requires_adaptation": False,
            }
            
            config["dependencies"].append(dep_info)
    
    return to_json(config)

def parse_moon_to_bazel_json(json_content):
    """Parse MoonBit JSON output for Bazel consumption.
    
    This handles the JSON metadata generated by MoonBit compiler
    and converts it to a format that Bazel can use for dependency
    management and build tracking.
    """
    try:
        data = from_json(json_content)
        
        # Extract relevant information for Bazel
        bazel_data = {
            "moonbit": {
                "version": data.get("version", "unknown"),
                "target": data.get("target", "wasm"),
                "optimization_level": data.get("optimization", "release"),
            },
            "dependencies": data.get("dependencies", []),
            "outputs": data.get("outputs", []),
            "warnings": data.get("warnings", []),
            "errors": data.get("errors", []),
            "timing": data.get("timing", {}),
        }
        
        return to_json(bazel_data)
    except Exception as e:
        # Fallback for malformed JSON
        return to_json({
            "error": "Failed to parse MoonBit JSON: " + str(e),
            "raw_content": json_content
        })

def generate_hermetic_build_config(ctx, output_file, target="wasm"):
    """Generate hermetic build configuration JSON.
    
    This creates a complete, hermetic build configuration that includes
    all toolchain information, platform details, and build settings.
    """
    config = {
        "hermetic_build": {
            "bazel_version": "7.0.0",
            "moonbit_version": "0.6.33",
            "platform": {
                "os": ctx.platform.os,
                "arch": ctx.platform.arch,
                "cpu": ctx.platform.cpu,
            },
            "toolchain": {
                "type": "hermetic",
                "source": "bazel_vendor",
                "checksum": "verified",
            },
            "target": target,
            "output": output_file.path,
            "timestamp": "2026-01-11T00:00:00Z",
            "build_id": ctx.label.name + "_" + str(hash(str(ctx.label))),
        }
    }
    
    return to_json(config)

def create_json_interop_files(ctx, srcs, deps, output_file, is_main=False, target=None):
    """Create complete JSON interop file set for Bazel-MoonBit communication.
    
    This generates all necessary JSON files for the integration:
    1. Build configuration (Bazel -> MoonBit)
    2. Dependency manifest
    3. Platform configuration
    4. Target-specific configuration
    5. Bazel integration configuration
    6. Output metadata template (MoonBit -> Bazel)
    
    Args:
        target: Optional compilation target (wasm, js, c, native)
    """
    files = {}
    
    # Auto-detect target if not specified
    if not target:
        target = get_target_from_label(ctx)
    
    # 1. Main build configuration (with target support)
    build_config = generate_bazel_to_moon_json(ctx, srcs, deps, is_main, target)
    files["build_config"] = (ctx.label.name + ".moon.build.json", build_config)
    
    # 2. Hermetic configuration
    hermetic_config = generate_hermetic_build_config(ctx, output_file)
    files["hermetic_config"] = (ctx.label.name + ".moon.hermetic.json", hermetic_config)
    
    # 3. Dependency manifest
    dep_manifest = generate_dependency_manifest(deps)
    files["dep_manifest"] = (ctx.label.name + ".moon.deps.json", dep_manifest)
    
    # 4. Target-specific configuration
    target_config = generate_target_specific_json(ctx, target, output_file)
    files["target_config"] = (ctx.label.name + ".moon.target." + target + ".json", 
                              to_json(target_config))
    
    # 5. Bazel integration configuration
    integration_config = generate_bazel_integration_config(target, output_file, ctx)
    files["integration_config"] = (ctx.label.name + ".moon.bazel.integration.json", 
                                   to_json(integration_config))
    
    return files

def generate_dependency_manifest(deps):
    """Generate dependency manifest JSON for hermetic dependency tracking."""
    manifest = {
        "dependencies": [],
        "transitive_dependencies": [],
        "dependency_graph": {},
        "target_compatibility": {}
    }
    
    for dep in deps:
        if hasattr(dep, 'label'):
            dep_entry = {
                "label": str(dep.label),
                "package": dep.label.package,
                "name": dep.label.name,
            }
            
            # Add to main dependencies
            manifest["dependencies"].append(dep_entry)
            
            # Build dependency graph
            manifest["dependency_graph"][str(dep.label)] = {
                "direct": True,
                "transitive": []
            }
            
            # Handle transitive dependencies
            if hasattr(dep, 'transitive_deps'):
                for trans_dep in dep.transitive_deps:
                    if hasattr(trans_dep, 'label'):
                        trans_entry = {
                            "label": str(trans_dep.label),
                            "package": trans_dep.label.package,
                            "name": trans_dep.label.name,
                        }
                        manifest["transitive_dependencies"].append(trans_entry)
                        manifest["dependency_graph"][str(dep.label)]["transitive"].append(str(trans_dep.label))
            
            # Add target compatibility info (would be populated by actual MoonBit compiler)
            manifest["target_compatibility"][str(dep.label)] = {
                "wasm": {"compatible": True, "requires_adaptation": False},
                "js": {"compatible": True, "requires_adaptation": False},
                "c": {"compatible": True, "requires_adaptation": True},
                "native": {"compatible": True, "requires_adaptation": False},
            }
    
    return to_json(manifest)