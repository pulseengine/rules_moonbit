"""MoonBit Foreign Function Interface (FFI) utilities - PRIVATE

This module provides comprehensive FFI support for MoonBit, enabling interoperability
with JavaScript, C, WebAssembly, and other languages.
"""

load(":platforms.bzl", "get_ffi_type", "get_target_from_label")
load(":json_utils.bzl", "generate_bazel_to_moon_json")

def generate_ffi_configuration(ctx, target=None, ffi_options=None):
    """Generate FFI configuration for MoonBit compilation.
    
    Args:
        target: Compilation target (wasm, js, c, native)
        ffi_options: Dictionary of FFI-specific options
    
    Returns:
        Dictionary containing FFI configuration
    """
    # Auto-detect target if not specified
    target = target or get_target_from_label(ctx)
    ffi_type = get_ffi_type(target)
    
    # Default FFI options
    default_options = {
        "wasm": {
            "imports": [],
            "exports": [],
            "memory": {"initial": 10, "maximum": 100},
            "tables": [],
            "globals": [],
            "features": ["bulk-memory", "reference-types", "gc"],
        },
        "js": {
            "module_system": "esm",
            "browser_compatible": True,
            "node_compatible": True,
            "npm_dependencies": [],
            "esm_imports": [],
            "commonjs_imports": [],
        },
        "c": {
            "header_file": "auto",
            "include_paths": [],
            "link_libraries": [],
            "compiler_flags": ["-std=c11", "-Wall"],
            "memory_management": "reference_counting",
        },
        "native": {
            "system_libraries": [],
            "include_paths": [],
            "link_libraries": [],
            "compiler_flags": [],
        }
    }
    
    # Merge with user-provided options
    ffi_config = default_options.get(target, default_options["wasm"])
    if ffi_options:
        ffi_config.update(ffi_options)
    
    # Add target-specific FFI information
    ffi_config["target"] = target
    ffi_config["ffi_type"] = ffi_type
    ffi_config["moonbit_specific"] = True
    
    return ffi_config

def create_ffi_bindings(ctx, target, ffi_config):
    """Create FFI bindings for the specified target.
    
    Args:
        target: Compilation target
        ffi_config: FFI configuration dictionary
    
    Returns:
        Dictionary containing binding files and metadata
    """
    bindings = {}
    
    if target == "wasm":
        # WebAssembly FFI bindings
        bindings["wasm"] = create_wasm_ffi_bindings(ctx, ffi_config)
    elif target == "js":
        # JavaScript FFI bindings
        bindings["js"] = create_js_ffi_bindings(ctx, ffi_config)
    elif target == "c":
        # C FFI bindings
        bindings["c"] = create_c_ffi_bindings(ctx, ffi_config)
    elif target == "native":
        # Native FFI bindings
        bindings["native"] = create_native_ffi_bindings(ctx, ffi_config)
    
    # Add FFI metadata
    bindings["metadata"] = generate_ffi_metadata(ctx, target, ffi_config)
    
    return bindings

def create_wasm_ffi_bindings(ctx, ffi_config):
    """Create WebAssembly FFI bindings."""
    bindings_file = ctx.actions.declare_file(ctx.label.name + ".ffi.wasm.h")
    
    # Generate WebAssembly FFI header
    ffi_header = """
// MoonBit FFI Bindings for WebAssembly
// Generated by rules_moonbit

#ifndef MOONBIT_FFI_WASM_H
#define MOONBIT_FFI_WASM_H

#include <stdint.h>
#include <stdbool.h>

// Memory management
void* moonbit_ffi_alloc(size_t size);
void moonbit_ffi_free(void* ptr);

// Import/Export management
void moonbit_ffi_import(const char* module, const char* name, void* func);
void* moonbit_ffi_export(const char* name, void* func);

// Type conversion utilities
int32_t moonbit_ffi_to_i32(void* value);
int64_t moonbit_ffi_to_i64(void* value);
float moonbit_ffi_to_f32(void* value);
double moonbit_ffi_to_f64(void* value);

// Error handling
void moonbit_ffi_set_error(const char* message);
const char* moonbit_ffi_get_error();

#endif // MOONBIT_FFI_WASM_H
"""
    
    ctx.actions.write(
        output = bindings_file,
        content = ffi_header,
        is_executable = False,
    )
    
    return {
        "header_file": bindings_file,
        "imports": ffi_config.get("imports", []),
        "exports": ffi_config.get("exports", []),
        "memory": ffi_config.get("memory", {}),
    }

def create_js_ffi_bindings(ctx, ffi_config):
    """Create JavaScript FFI bindings."""
    bindings_file = ctx.actions.declare_file(ctx.label.name + ".ffi.js")
    
    # Generate JavaScript FFI bindings
    ffi_js = """
// MoonBit FFI Bindings for JavaScript
// Generated by rules_moonbit

/**
 * MoonBit FFI Utilities
 * @module moonbit/ffi
 */

export class MoonBitFFI {
    constructor() {
        this.imports = new Map();
        this.exports = new Map();
        this.error = null;
    }

    /**
     * Import a JavaScript function
     * @param {string} name - Function name
     * @param {Function} func - JavaScript function
     */
    import(name, func) {
        this.imports.set(name, func);
    }

    /**
     * Export a function to MoonBit
     * @param {string} name - Function name
     * @param {Function} func - Function to export
     */
    export(name, func) {
        this.exports.set(name, func);
    }

    /**
     * Call an imported function
     * @param {string} name - Function name
     * @param {...any} args - Arguments
     * @returns {any} Result
     */
    callImport(name, ...args) {
        const func = this.imports.get(name);
        if (!func) {
            throw new Error(`FFI import '${name}' not found`);
        }
        return func(...args);
    }

    /**
     * Call an exported function
     * @param {string} name - Function name
     * @param {...any} args - Arguments
     * @returns {any} Result
     */
    callExport(name, ...args) {
        const func = this.exports.get(name);
        if (!func) {
            throw new Error(`FFI export '${name}' not found`);
        }
        return func(...args);
    }

    /**
     * Set error message
     * @param {string} message - Error message
     */
    setError(message) {
        this.error = message;
    }

    /**
     * Get current error
     * @returns {string|null} Error message
     */
    getError() {
        return this.error;
    }

    /**
     * Convert JavaScript value to MoonBit type
     * @param {any} value - JavaScript value
     * @returns {any} Converted value
     */
    toMoonBit(value) {
        // Type conversion logic would go here
        return value;
    }

    /**
     * Convert MoonBit value to JavaScript type
     * @param {any} value - MoonBit value
     * @returns {any} Converted value
     */
    fromMoonBit(value) {
        // Type conversion logic would go here
        return value;
    }
}

export const ffi = new MoonBitFFI();

export default ffi;
"""
    
    ctx.actions.write(
        output = bindings_file,
        content = ffi_js,
        is_executable = False,
    )
    
    return {
        "bindings_file": bindings_file,
        "module_system": ffi_config.get("module_system", "esm"),
        "npm_dependencies": ffi_config.get("npm_dependencies", []),
    }

def create_c_ffi_bindings(ctx, ffi_config):
    """Create C FFI bindings."""
    header_file = ctx.actions.declare_file(ctx.label.name + ".ffi.h")
    source_file = ctx.actions.declare_file(ctx.label.name + ".ffi.c")
    
    # Generate C FFI header
    ffi_header = """
// MoonBit FFI Bindings for C
// Generated by rules_moonbit

#ifndef MOONBIT_FFI_C_H
#define MOONBIT_FFI_C_H

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>

// Memory management
void* moonbit_ffi_malloc(size_t size);
void moonbit_ffi_free(void* ptr);
void* moonbit_ffi_realloc(void* ptr, size_t size);

// Type conversion
int32_t moonbit_ffi_to_int32(void* value);
int64_t moonbit_ffi_to_int64(void* value);
float moonbit_ffi_to_float(void* value);
double moonbit_ffi_to_double(void* value);

// String handling
char* moonbit_ffi_to_string(void* value);
void* moonbit_ffi_from_string(const char* str);
void moonbit_ffi_free_string(char* str);

// Error handling
void moonbit_ffi_set_error(const char* message);
const char* moonbit_ffi_get_error();
void moonbit_ffi_clear_error();

// Function pointer management
void moonbit_ffi_register_function(const char* name, void* func);
void* moonbit_ffi_get_function(const char* name);

// Type information
const char* moonbit_ffi_get_type_name(void* value);
int moonbit_ffi_get_type_id(void* value);

#endif // MOONBIT_FFI_C_H
"""
    
    # Generate C FFI source
    ffi_source = """
// MoonBit FFI Bindings for C - Implementation
// Generated by rules_moonbit

#include "{label_name}.ffi.h"
#include <string.h>
#include <stdio.h>

// Memory management
void* moonbit_ffi_malloc(size_t size) {{
    return malloc(size);
}}

void moonbit_ffi_free(void* ptr) {{
    free(ptr);
}}

void* moonbit_ffi_realloc(void* ptr, size_t size) {{
    return realloc(ptr, size);
}}

// Type conversion (simplified)
int32_t moonbit_ffi_to_int32(void* value) {{
    return *(int32_t*)value;
}}

int64_t moonbit_ffi_to_int64(void* value) {{
    return *(int64_t*)value;
}}

float moonbit_ffi_to_float(void* value) {{
    return *(float*)value;
}}

double moonbit_ffi_to_double(void* value) {{
    return *(double*)value;
}}

// String handling
char* moonbit_ffi_to_string(void* value) {{
    // Simplified string conversion
    return (char*)value;
}}

void* moonbit_ffi_from_string(const char* str) {{
    size_t len = strlen(str) + 1;
    char* copy = moonbit_ffi_malloc(len);
    strcpy(copy, str);
    return copy;
}}

void moonbit_ffi_free_string(char* str) {{
    moonbit_ffi_free(str);
}}

// Error handling
static char* ffi_error = NULL;

void moonbit_ffi_set_error(const char* message) {{
    if (ffi_error) moonbit_ffi_free(ffi_error);
    ffi_error = moonbit_ffi_from_string(message);
}}

const char* moonbit_ffi_get_error() {{
    return ffi_error;
}}

void moonbit_ffi_clear_error() {{
    if (ffi_error) moonbit_ffi_free(ffi_error);
    ffi_error = NULL;
}}

// Function pointer management
// Would be implemented with proper function pointer handling
void moonbit_ffi_register_function(const char* name, void* func) {
    // Implementation would go here
}

void* moonbit_ffi_get_function(const char* name) {
    // Implementation would go here
    return NULL;
}

// Type information
const char* moonbit_ffi_get_type_name(void* value) {
    // Implementation would go here
    return "unknown";
}

int moonbit_ffi_get_type_id(void* value) {
    // Implementation would go here
    return 0;
}
".replace("{label_name}", ctx.label.name)
    
    ctx.actions.write(
        output = header_file,
        content = ffi_header,
        is_executable = False,
    )
    
    ctx.actions.write(
        output = source_file,
        content = ffi_source,
        is_executable = False,
    )
    
    return {
        "header_file": header_file,
        "source_file": source_file,
        "include_paths": ffi_config.get("include_paths", []),
        "link_libraries": ffi_config.get("link_libraries", []),
    }

def create_native_ffi_bindings(ctx, ffi_config):
    """Create native FFI bindings."""
    # Native FFI bindings would be similar to C but with platform-specific features
    # For now, we'll reuse the C bindings approach
    return create_c_ffi_bindings(ctx, ffi_config)

def generate_ffi_metadata(ctx, target, ffi_config):
    """Generate FFI metadata for build tracking."""
    metadata = {
        "ffi": {
            "target": target,
            "ffi_type": ffi_config.get("ffi_type", "unknown"),
            "moonbit_specific": True,
            "generated_files": [],
            "configuration": ffi_config,
        }
    }
    
    return metadata

def create_ffi_compilation_action(ctx, target, ffi_config):
    """Create FFI compilation action that integrates with MoonBit compilation."""
    # Generate FFI bindings
    ffi_bindings = create_ffi_bindings(ctx, target, ffi_config)
    
    # Create FFI metadata file
    ffi_metadata_file = ctx.actions.declare_file(ctx.label.name + ".ffi.metadata.json")
    
    # Write FFI metadata
    ctx.actions.write(
        output = ffi_metadata_file,
        content = str(ffi_bindings["metadata"]),
        is_executable = False,
    )
    
    # Return FFI information
    return {
        "bindings": ffi_bindings,
        "metadata_file": ffi_metadata_file,
        "target": target,
        "ffi_type": ffi_config.get("ffi_type", "unknown"),
    }

def generate_ffi_integration_json(ctx, target, ffi_config):
    """Generate JSON configuration for FFI integration."""
    config = {
        "ffi_integration": {
            "target": target,
            "ffi_type": get_ffi_type(target),
            "moonbit_specific": True,
            "configuration": ffi_config,
            "generated_files": [],
        }
    }
    
    return config